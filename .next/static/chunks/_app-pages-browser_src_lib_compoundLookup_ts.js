"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_lib_compoundLookup_ts"],{

/***/ "(app-pages-browser)/./src/lib/compoundLookup.ts":
/*!***********************************!*\
  !*** ./src/lib/compoundLookup.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getElementWikipediaUrl: function() { return /* binding */ getElementWikipediaUrl; },\n/* harmony export */   lookupCompound: function() { return /* binding */ lookupCompound; }\n/* harmony export */ });\n// Cache for compounds\nconst compoundCache = new Map();\nlet compoundsDatabase = null;\nasync function lookupCompound(elements) {\n    // Normalize element names and create lookup keys\n    const elementNames = elements.map((el)=>el.name);\n    const sortedNames = [\n        ...elementNames\n    ].sort();\n    // Generate all possible permutations for lookup\n    const lookupKeys = new Set();\n    // Add basic combinations\n    lookupKeys.add(elementNames.join(\"+\"));\n    lookupKeys.add(sortedNames.join(\"+\"));\n    lookupKeys.add(elementNames.reverse().join(\"+\"));\n    // For 3+ elements, try different groupings\n    if (elementNames.length >= 3) {\n        const permutations = getPermutations(elementNames);\n        permutations.forEach((perm)=>lookupKeys.add(perm.join(\"+\")));\n    }\n    const lookupKeysArray = Array.from(lookupKeys);\n    // Looking up compound for elements\n    // Check cache first for any of the keys\n    for (const key of lookupKeysArray){\n        if (compoundCache.has(key)) {\n            // Found in cache\n            return compoundCache.get(key) || null;\n        }\n    }\n    // Load compounds database if not loaded\n    if (!compoundsDatabase) {\n        try {\n            const response = await fetch(\"/data/compounds.json\");\n            if (!response.ok) {\n                throw new Error(\"HTTP error! status: \".concat(response.status));\n            }\n            compoundsDatabase = await response.json();\n        // Loaded compounds database successfully\n        } catch (error) {\n            console.error(\"Failed to load compounds database:\", error);\n            compoundsDatabase = {};\n        }\n    }\n    // Check local database with all possible keys\n    if (compoundsDatabase) {\n        for (const key of lookupKeysArray){\n            const localCompound = compoundsDatabase[key];\n            if (localCompound) {\n                // Found in local database\n                compoundCache.set(sortedNames.join(\"+\"), localCompound);\n                return localCompound;\n            }\n        }\n    }\n    // Not found in local database, querying PubChem API\n    // Query PubChem API for comprehensive compound database\n    try {\n        const pubchemCompound = await queryPubChemByElements(elements);\n        if (pubchemCompound) {\n            // Found compound via PubChem\n            compoundCache.set(sortedNames.join(\"+\"), pubchemCompound);\n            return pubchemCompound;\n        }\n    } catch (error) {\n        console.error(\"PubChem query failed:\", error);\n    }\n    // Cache negative result to avoid repeated API calls\n    compoundCache.set(sortedNames.join(\"+\"), null);\n    return null;\n}\nasync function queryPubChemByElements(elements) {\n    try {\n        // Generate possible molecular formulas\n        const formulas = generatePossibleFormulas(elements);\n        // Try each formula with PubChem\n        for (const formula of formulas){\n            const compound = await queryPubChemByFormula(formula);\n            if (compound) {\n                return compound;\n            }\n        }\n        // Try name-based search as fallback\n        const nameQuery = elements.map((el)=>el.name.toLowerCase()).sort().join(\" \");\n        const nameCompound = await queryPubChemByName(nameQuery);\n        if (nameCompound) {\n            return nameCompound;\n        }\n        return null;\n    } catch (error) {\n        return null;\n    }\n}\nasync function queryPubChemByFormula(formula) {\n    try {\n        var _compound_id_id, _compound_id, _propsData_PropertyTable_Properties, _propsData_PropertyTable;\n        const searchUrl = \"https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/formula/\".concat(formula, \"/JSON\");\n        const response = await fetch(searchUrl);\n        if (!response.ok) return null;\n        const data = await response.json();\n        const compounds = data.PC_Compounds;\n        if (!compounds || compounds.length === 0) return null;\n        // Get the first compound\n        const compound = compounds[0];\n        const cid = (_compound_id = compound.id) === null || _compound_id === void 0 ? void 0 : (_compound_id_id = _compound_id.id) === null || _compound_id_id === void 0 ? void 0 : _compound_id_id.cid;\n        if (!cid) return null;\n        // Get detailed properties\n        const propsUrl = \"https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/\".concat(cid, \"/property/MolecularFormula,IUPACName,MolecularWeight,CanonicalSMILES/JSON\");\n        const propsResponse = await fetch(propsUrl);\n        if (!propsResponse.ok) return null;\n        const propsData = await propsResponse.json();\n        const props = (_propsData_PropertyTable = propsData.PropertyTable) === null || _propsData_PropertyTable === void 0 ? void 0 : (_propsData_PropertyTable_Properties = _propsData_PropertyTable.Properties) === null || _propsData_PropertyTable_Properties === void 0 ? void 0 : _propsData_PropertyTable_Properties[0];\n        if (!props) return null;\n        const name = props.IUPACName || props.MolecularFormula || \"Unknown compound\";\n        return {\n            elements: [],\n            formula: props.MolecularFormula || formula,\n            name: name.length > 50 ? props.MolecularFormula : name,\n            properties: {\n                state: \"Unknown\",\n                melting_point: \"Unknown\",\n                boiling_point: \"Unknown\",\n                density: \"Unknown\"\n            },\n            uses: [\n                \"Chemical compound\",\n                \"Research\",\n                \"Industrial applications\"\n            ],\n            links: {\n                wikipedia: \"https://en.wikipedia.org/wiki/\".concat(encodeURIComponent(name)),\n                pubchem: \"https://pubchem.ncbi.nlm.nih.gov/compound/\".concat(cid)\n            }\n        };\n    } catch (error) {\n        return null;\n    }\n}\nasync function queryPubChemByName(nameQuery) {\n    try {\n        var _compound_id_id, _compound_id, _propsData_PropertyTable_Properties, _propsData_PropertyTable;\n        const searchUrl = \"https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/name/\".concat(encodeURIComponent(nameQuery), \"/JSON\");\n        const response = await fetch(searchUrl);\n        if (!response.ok) return null;\n        const data = await response.json();\n        const compounds = data.PC_Compounds;\n        if (!compounds || compounds.length === 0) return null;\n        const compound = compounds[0];\n        const cid = (_compound_id = compound.id) === null || _compound_id === void 0 ? void 0 : (_compound_id_id = _compound_id.id) === null || _compound_id_id === void 0 ? void 0 : _compound_id_id.cid;\n        if (!cid) return null;\n        const propsUrl = \"https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/\".concat(cid, \"/property/MolecularFormula,IUPACName,MolecularWeight/JSON\");\n        const propsResponse = await fetch(propsUrl);\n        if (!propsResponse.ok) return null;\n        const propsData = await propsResponse.json();\n        const props = (_propsData_PropertyTable = propsData.PropertyTable) === null || _propsData_PropertyTable === void 0 ? void 0 : (_propsData_PropertyTable_Properties = _propsData_PropertyTable.Properties) === null || _propsData_PropertyTable_Properties === void 0 ? void 0 : _propsData_PropertyTable_Properties[0];\n        if (!props) return null;\n        const name = props.IUPACName || nameQuery;\n        return {\n            elements: [],\n            formula: props.MolecularFormula || \"Unknown\",\n            name: name.length > 50 ? props.MolecularFormula : name,\n            properties: {\n                state: \"Unknown\",\n                melting_point: \"Unknown\",\n                boiling_point: \"Unknown\",\n                density: \"Unknown\"\n            },\n            uses: [\n                \"Chemical compound\",\n                \"Research\",\n                \"Industrial applications\"\n            ],\n            links: {\n                wikipedia: \"https://en.wikipedia.org/wiki/\".concat(encodeURIComponent(name)),\n                pubchem: \"https://pubchem.ncbi.nlm.nih.gov/compound/\".concat(cid)\n            }\n        };\n    } catch (error) {\n        return null;\n    }\n}\nfunction generatePossibleFormulas(elements) {\n    const formulas = [];\n    const symbols = elements.map((el)=>el.symbol);\n    if (elements.length === 2) {\n        const [s1, s2] = symbols;\n        formulas.push(\"\".concat(s1).concat(s2), \"\".concat(s2).concat(s1), \"\".concat(s1, \"2\").concat(s2), \"\".concat(s2, \"2\").concat(s1), \"\".concat(s1).concat(s2, \"2\"), \"\".concat(s2).concat(s1, \"2\"), \"\".concat(s1, \"2\").concat(s2, \"3\"), \"\".concat(s2, \"2\").concat(s1, \"3\"), \"\".concat(s1, \"3\").concat(s2, \"2\"), \"\".concat(s2, \"3\").concat(s1, \"2\"), \"\".concat(s1, \"3\").concat(s2), \"\".concat(s2, \"3\").concat(s1), \"\".concat(s1).concat(s2, \"3\"), \"\".concat(s2).concat(s1, \"3\"), \"\".concat(s1, \"4\").concat(s2), \"\".concat(s2, \"4\").concat(s1));\n    } else if (elements.length === 3) {\n        const [s1, s2, s3] = symbols;\n        formulas.push(\"\".concat(s1).concat(s2).concat(s3), \"\".concat(s1).concat(s3).concat(s2), \"\".concat(s2).concat(s1).concat(s3), \"\".concat(s2).concat(s3).concat(s1), \"\".concat(s3).concat(s1).concat(s2), \"\".concat(s3).concat(s2).concat(s1), \"\".concat(s1, \"2\").concat(s2).concat(s3), \"\".concat(s1).concat(s2, \"2\").concat(s3), \"\".concat(s1).concat(s2).concat(s3, \"2\"), \"\".concat(s1).concat(s2).concat(s3, \"3\"), \"\".concat(s1).concat(s2, \"3\").concat(s3), \"\".concat(s1, \"3\").concat(s2).concat(s3));\n    } else if (elements.length >= 4) {\n        // For 4+ elements, try basic combinations\n        formulas.push(symbols.join(\"\"));\n        formulas.push(symbols.reverse().join(\"\"));\n    }\n    return Array.from(new Set(formulas));\n}\nfunction getPermutations(arr) {\n    if (arr.length <= 1) return [\n        arr\n    ];\n    const result = [];\n    for(let i = 0; i < arr.length; i++){\n        const rest = [\n            ...arr.slice(0, i),\n            ...arr.slice(i + 1)\n        ];\n        const perms = getPermutations(rest);\n        for (const perm of perms){\n            result.push([\n                arr[i],\n                ...perm\n            ]);\n        }\n    }\n    return result;\n}\nfunction getElementWikipediaUrl(elementName) {\n    return \"https://en.wikipedia.org/wiki/\".concat(encodeURIComponent(elementName));\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvY29tcG91bmRMb29rdXAudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFpQkEsc0JBQXNCO0FBQ3RCLE1BQU1BLGdCQUFnQixJQUFJQztBQUMxQixJQUFJQyxvQkFBeUQ7QUFFdEQsZUFBZUMsZUFBZUMsUUFBNEM7SUFDL0UsaURBQWlEO0lBQ2pELE1BQU1DLGVBQWVELFNBQVNFLEdBQUcsQ0FBQ0MsQ0FBQUEsS0FBTUEsR0FBR0MsSUFBSTtJQUMvQyxNQUFNQyxjQUFjO1dBQUlKO0tBQWEsQ0FBQ0ssSUFBSTtJQUUxQyxnREFBZ0Q7SUFDaEQsTUFBTUMsYUFBYSxJQUFJQztJQUV2Qix5QkFBeUI7SUFDekJELFdBQVdFLEdBQUcsQ0FBQ1IsYUFBYVMsSUFBSSxDQUFDO0lBQ2pDSCxXQUFXRSxHQUFHLENBQUNKLFlBQVlLLElBQUksQ0FBQztJQUNoQ0gsV0FBV0UsR0FBRyxDQUFDUixhQUFhVSxPQUFPLEdBQUdELElBQUksQ0FBQztJQUUzQywyQ0FBMkM7SUFDM0MsSUFBSVQsYUFBYVcsTUFBTSxJQUFJLEdBQUc7UUFDNUIsTUFBTUMsZUFBZUMsZ0JBQWdCYjtRQUNyQ1ksYUFBYUUsT0FBTyxDQUFDQyxDQUFBQSxPQUFRVCxXQUFXRSxHQUFHLENBQUNPLEtBQUtOLElBQUksQ0FBQztJQUN4RDtJQUVBLE1BQU1PLGtCQUFrQkMsTUFBTUMsSUFBSSxDQUFDWjtJQUVuQyxtQ0FBbUM7SUFFbkMsd0NBQXdDO0lBQ3hDLEtBQUssTUFBTWEsT0FBT0gsZ0JBQWlCO1FBQ2pDLElBQUlyQixjQUFjeUIsR0FBRyxDQUFDRCxNQUFNO1lBQzFCLGlCQUFpQjtZQUNqQixPQUFPeEIsY0FBYzBCLEdBQUcsQ0FBQ0YsUUFBUTtRQUNuQztJQUNGO0lBRUEsd0NBQXdDO0lBQ3hDLElBQUksQ0FBQ3RCLG1CQUFtQjtRQUN0QixJQUFJO1lBQ0YsTUFBTXlCLFdBQVcsTUFBTUMsTUFBTTtZQUM3QixJQUFJLENBQUNELFNBQVNFLEVBQUUsRUFB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bXBvdW5kTG9va3VwLnRzP2FjZTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW50ZXJmYWNlIENvbXBvdW5kRGF0YSB7XHJcbiAgZWxlbWVudHM6IHN0cmluZ1tdO1xyXG4gIGZvcm11bGE6IHN0cmluZztcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgcHJvcGVydGllczoge1xyXG4gICAgc3RhdGU6IHN0cmluZztcclxuICAgIG1lbHRpbmdfcG9pbnQ6IHN0cmluZztcclxuICAgIGJvaWxpbmdfcG9pbnQ6IHN0cmluZztcclxuICAgIGRlbnNpdHk6IHN0cmluZztcclxuICB9O1xyXG4gIHVzZXM6IHN0cmluZ1tdO1xyXG4gIGxpbmtzOiB7XHJcbiAgICB3aWtpcGVkaWE6IHN0cmluZztcclxuICAgIHB1YmNoZW06IHN0cmluZztcclxuICB9O1xyXG59XHJcblxyXG4vLyBDYWNoZSBmb3IgY29tcG91bmRzXHJcbmNvbnN0IGNvbXBvdW5kQ2FjaGUgPSBuZXcgTWFwPHN0cmluZywgQ29tcG91bmREYXRhIHwgbnVsbD4oKTtcclxubGV0IGNvbXBvdW5kc0RhdGFiYXNlOiBSZWNvcmQ8c3RyaW5nLCBDb21wb3VuZERhdGE+IHwgbnVsbCA9IG51bGw7XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9va3VwQ29tcG91bmQoZWxlbWVudHM6IHsgc3ltYm9sOiBzdHJpbmc7IG5hbWU6IHN0cmluZyB9W10pOiBQcm9taXNlPENvbXBvdW5kRGF0YSB8IG51bGw+IHtcclxuICAvLyBOb3JtYWxpemUgZWxlbWVudCBuYW1lcyBhbmQgY3JlYXRlIGxvb2t1cCBrZXlzXHJcbiAgY29uc3QgZWxlbWVudE5hbWVzID0gZWxlbWVudHMubWFwKGVsID0+IGVsLm5hbWUpO1xyXG4gIGNvbnN0IHNvcnRlZE5hbWVzID0gWy4uLmVsZW1lbnROYW1lc10uc29ydCgpO1xyXG4gIFxyXG4gIC8vIEdlbmVyYXRlIGFsbCBwb3NzaWJsZSBwZXJtdXRhdGlvbnMgZm9yIGxvb2t1cFxyXG4gIGNvbnN0IGxvb2t1cEtleXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcclxuICBcclxuICAvLyBBZGQgYmFzaWMgY29tYmluYXRpb25zXHJcbiAgbG9va3VwS2V5cy5hZGQoZWxlbWVudE5hbWVzLmpvaW4oJysnKSk7XHJcbiAgbG9va3VwS2V5cy5hZGQoc29ydGVkTmFtZXMuam9pbignKycpKTtcclxuICBsb29rdXBLZXlzLmFkZChlbGVtZW50TmFtZXMucmV2ZXJzZSgpLmpvaW4oJysnKSk7XHJcbiAgXHJcbiAgLy8gRm9yIDMrIGVsZW1lbnRzLCB0cnkgZGlmZmVyZW50IGdyb3VwaW5nc1xyXG4gIGlmIChlbGVtZW50TmFtZXMubGVuZ3RoID49IDMpIHtcclxuICAgIGNvbnN0IHBlcm11dGF0aW9ucyA9IGdldFBlcm11dGF0aW9ucyhlbGVtZW50TmFtZXMpO1xyXG4gICAgcGVybXV0YXRpb25zLmZvckVhY2gocGVybSA9PiBsb29rdXBLZXlzLmFkZChwZXJtLmpvaW4oJysnKSkpO1xyXG4gIH1cclxuICBcclxuICBjb25zdCBsb29rdXBLZXlzQXJyYXkgPSBBcnJheS5mcm9tKGxvb2t1cEtleXMpO1xyXG4gIFxyXG4gIC8vIExvb2tpbmcgdXAgY29tcG91bmQgZm9yIGVsZW1lbnRzXHJcbiAgXHJcbiAgLy8gQ2hlY2sgY2FjaGUgZmlyc3QgZm9yIGFueSBvZiB0aGUga2V5c1xyXG4gIGZvciAoY29uc3Qga2V5IG9mIGxvb2t1cEtleXNBcnJheSkge1xyXG4gICAgaWYgKGNvbXBvdW5kQ2FjaGUuaGFzKGtleSkpIHtcclxuICAgICAgLy8gRm91bmQgaW4gY2FjaGVcclxuICAgICAgcmV0dXJuIGNvbXBvdW5kQ2FjaGUuZ2V0KGtleSkgfHwgbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIExvYWQgY29tcG91bmRzIGRhdGFiYXNlIGlmIG5vdCBsb2FkZWRcclxuICBpZiAoIWNvbXBvdW5kc0RhdGFiYXNlKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvZGF0YS9jb21wb3VuZHMuanNvbicpO1xyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbXBvdW5kc0RhdGFiYXNlID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAvLyBMb2FkZWQgY29tcG91bmRzIGRhdGFiYXNlIHN1Y2Nlc3NmdWxseVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvYWQgY29tcG91bmRzIGRhdGFiYXNlOicsIGVycm9yKTtcclxuICAgICAgY29tcG91bmRzRGF0YWJhc2UgPSB7fTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIENoZWNrIGxvY2FsIGRhdGFiYXNlIHdpdGggYWxsIHBvc3NpYmxlIGtleXNcclxuICBpZiAoY29tcG91bmRzRGF0YWJhc2UpIHtcclxuICAgIGZvciAoY29uc3Qga2V5IG9mIGxvb2t1cEtleXNBcnJheSkge1xyXG4gICAgICBjb25zdCBsb2NhbENvbXBvdW5kID0gY29tcG91bmRzRGF0YWJhc2Vba2V5XTtcclxuICAgICAgaWYgKGxvY2FsQ29tcG91bmQpIHtcclxuICAgICAgICAvLyBGb3VuZCBpbiBsb2NhbCBkYXRhYmFzZVxyXG4gICAgICAgIGNvbXBvdW5kQ2FjaGUuc2V0KHNvcnRlZE5hbWVzLmpvaW4oJysnKSwgbG9jYWxDb21wb3VuZCk7XHJcbiAgICAgICAgcmV0dXJuIGxvY2FsQ29tcG91bmQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIE5vdCBmb3VuZCBpbiBsb2NhbCBkYXRhYmFzZSwgcXVlcnlpbmcgUHViQ2hlbSBBUElcclxuICBcclxuICAvLyBRdWVyeSBQdWJDaGVtIEFQSSBmb3IgY29tcHJlaGVuc2l2ZSBjb21wb3VuZCBkYXRhYmFzZVxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBwdWJjaGVtQ29tcG91bmQgPSBhd2FpdCBxdWVyeVB1YkNoZW1CeUVsZW1lbnRzKGVsZW1lbnRzKTtcclxuICAgIGlmIChwdWJjaGVtQ29tcG91bmQpIHtcclxuICAgICAgLy8gRm91bmQgY29tcG91bmQgdmlhIFB1YkNoZW1cclxuICAgICAgY29tcG91bmRDYWNoZS5zZXQoc29ydGVkTmFtZXMuam9pbignKycpLCBwdWJjaGVtQ29tcG91bmQpO1xyXG4gICAgICByZXR1cm4gcHViY2hlbUNvbXBvdW5kO1xyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdQdWJDaGVtIHF1ZXJ5IGZhaWxlZDonLCBlcnJvcik7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIENhY2hlIG5lZ2F0aXZlIHJlc3VsdCB0byBhdm9pZCByZXBlYXRlZCBBUEkgY2FsbHNcclxuICBjb21wb3VuZENhY2hlLnNldChzb3J0ZWROYW1lcy5qb2luKCcrJyksIG51bGwpO1xyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBxdWVyeVB1YkNoZW1CeUVsZW1lbnRzKGVsZW1lbnRzOiB7IHN5bWJvbDogc3RyaW5nOyBuYW1lOiBzdHJpbmcgfVtdKTogUHJvbWlzZTxDb21wb3VuZERhdGEgfCBudWxsPiB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIEdlbmVyYXRlIHBvc3NpYmxlIG1vbGVjdWxhciBmb3JtdWxhc1xyXG4gICAgY29uc3QgZm9ybXVsYXMgPSBnZW5lcmF0ZVBvc3NpYmxlRm9ybXVsYXMoZWxlbWVudHMpO1xyXG4gICAgXHJcbiAgICAvLyBUcnkgZWFjaCBmb3JtdWxhIHdpdGggUHViQ2hlbVxyXG4gICAgZm9yIChjb25zdCBmb3JtdWxhIG9mIGZvcm11bGFzKSB7XHJcbiAgICAgIGNvbnN0IGNvbXBvdW5kID0gYXdhaXQgcXVlcnlQdWJDaGVtQnlGb3JtdWxhKGZvcm11bGEpO1xyXG4gICAgICBpZiAoY29tcG91bmQpIHtcclxuICAgICAgICByZXR1cm4gY29tcG91bmQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gVHJ5IG5hbWUtYmFzZWQgc2VhcmNoIGFzIGZhbGxiYWNrXHJcbiAgICBjb25zdCBuYW1lUXVlcnkgPSBlbGVtZW50cy5tYXAoZWwgPT4gZWwubmFtZS50b0xvd2VyQ2FzZSgpKS5zb3J0KCkuam9pbignICcpO1xyXG4gICAgY29uc3QgbmFtZUNvbXBvdW5kID0gYXdhaXQgcXVlcnlQdWJDaGVtQnlOYW1lKG5hbWVRdWVyeSk7XHJcbiAgICBpZiAobmFtZUNvbXBvdW5kKSB7XHJcbiAgICAgIHJldHVybiBuYW1lQ29tcG91bmQ7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIHF1ZXJ5UHViQ2hlbUJ5Rm9ybXVsYShmb3JtdWxhOiBzdHJpbmcpOiBQcm9taXNlPENvbXBvdW5kRGF0YSB8IG51bGw+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3Qgc2VhcmNoVXJsID0gYGh0dHBzOi8vcHViY2hlbS5uY2JpLm5sbS5uaWguZ292L3Jlc3QvcHVnL2NvbXBvdW5kL2Zvcm11bGEvJHtmb3JtdWxhfS9KU09OYDtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goc2VhcmNoVXJsKTtcclxuICAgIFxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykgcmV0dXJuIG51bGw7XHJcbiAgICBcclxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICBjb25zdCBjb21wb3VuZHMgPSBkYXRhLlBDX0NvbXBvdW5kcztcclxuICAgIFxyXG4gICAgaWYgKCFjb21wb3VuZHMgfHwgY29tcG91bmRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XHJcbiAgICBcclxuICAgIC8vIEdldCB0aGUgZmlyc3QgY29tcG91bmRcclxuICAgIGNvbnN0IGNvbXBvdW5kID0gY29tcG91bmRzWzBdO1xyXG4gICAgY29uc3QgY2lkID0gY29tcG91bmQuaWQ/LmlkPy5jaWQ7XHJcbiAgICBcclxuICAgIGlmICghY2lkKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAvLyBHZXQgZGV0YWlsZWQgcHJvcGVydGllc1xyXG4gICAgY29uc3QgcHJvcHNVcmwgPSBgaHR0cHM6Ly9wdWJjaGVtLm5jYmkubmxtLm5paC5nb3YvcmVzdC9wdWcvY29tcG91bmQvY2lkLyR7Y2lkfS9wcm9wZXJ0eS9Nb2xlY3VsYXJGb3JtdWxhLElVUEFDTmFtZSxNb2xlY3VsYXJXZWlnaHQsQ2Fub25pY2FsU01JTEVTL0pTT05gO1xyXG4gICAgY29uc3QgcHJvcHNSZXNwb25zZSA9IGF3YWl0IGZldGNoKHByb3BzVXJsKTtcclxuICAgIFxyXG4gICAgaWYgKCFwcm9wc1Jlc3BvbnNlLm9rKSByZXR1cm4gbnVsbDtcclxuICAgIFxyXG4gICAgY29uc3QgcHJvcHNEYXRhID0gYXdhaXQgcHJvcHNSZXNwb25zZS5qc29uKCk7XHJcbiAgICBjb25zdCBwcm9wcyA9IHByb3BzRGF0YS5Qcm9wZXJ0eVRhYmxlPy5Qcm9wZXJ0aWVzPy5bMF07XHJcbiAgICBcclxuICAgIGlmICghcHJvcHMpIHJldHVybiBudWxsO1xyXG5cclxuICAgIGNvbnN0IG5hbWUgPSBwcm9wcy5JVVBBQ05hbWUgfHwgcHJvcHMuTW9sZWN1bGFyRm9ybXVsYSB8fCAnVW5rbm93biBjb21wb3VuZCc7XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGVsZW1lbnRzOiBbXSxcclxuICAgICAgZm9ybXVsYTogcHJvcHMuTW9sZWN1bGFyRm9ybXVsYSB8fCBmb3JtdWxhLFxyXG4gICAgICBuYW1lOiBuYW1lLmxlbmd0aCA+IDUwID8gcHJvcHMuTW9sZWN1bGFyRm9ybXVsYSA6IG5hbWUsXHJcbiAgICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICBzdGF0ZTogJ1Vua25vd24nLFxyXG4gICAgICAgIG1lbHRpbmdfcG9pbnQ6ICdVbmtub3duJyxcclxuICAgICAgICBib2lsaW5nX3BvaW50OiAnVW5rbm93bicsXHJcbiAgICAgICAgZGVuc2l0eTogJ1Vua25vd24nXHJcbiAgICAgIH0sXHJcbiAgICAgIHVzZXM6IFsnQ2hlbWljYWwgY29tcG91bmQnLCAnUmVzZWFyY2gnLCAnSW5kdXN0cmlhbCBhcHBsaWNhdGlvbnMnXSxcclxuICAgICAgbGlua3M6IHtcclxuICAgICAgICB3aWtpcGVkaWE6IGBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS8ke2VuY29kZVVSSUNvbXBvbmVudChuYW1lKX1gLFxyXG4gICAgICAgIHB1YmNoZW06IGBodHRwczovL3B1YmNoZW0ubmNiaS5ubG0ubmloLmdvdi9jb21wb3VuZC8ke2NpZH1gXHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gcXVlcnlQdWJDaGVtQnlOYW1lKG5hbWVRdWVyeTogc3RyaW5nKTogUHJvbWlzZTxDb21wb3VuZERhdGEgfCBudWxsPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHNlYXJjaFVybCA9IGBodHRwczovL3B1YmNoZW0ubmNiaS5ubG0ubmloLmdvdi9yZXN0L3B1Zy9jb21wb3VuZC9uYW1lLyR7ZW5jb2RlVVJJQ29tcG9uZW50KG5hbWVRdWVyeSl9L0pTT05gO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChzZWFyY2hVcmwpO1xyXG4gICAgXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSByZXR1cm4gbnVsbDtcclxuICAgIFxyXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgIGNvbnN0IGNvbXBvdW5kcyA9IGRhdGEuUENfQ29tcG91bmRzO1xyXG4gICAgXHJcbiAgICBpZiAoIWNvbXBvdW5kcyB8fCBjb21wb3VuZHMubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcclxuICAgIFxyXG4gICAgY29uc3QgY29tcG91bmQgPSBjb21wb3VuZHNbMF07XHJcbiAgICBjb25zdCBjaWQgPSBjb21wb3VuZC5pZD8uaWQ/LmNpZDtcclxuICAgIFxyXG4gICAgaWYgKCFjaWQpIHJldHVybiBudWxsO1xyXG5cclxuICAgIGNvbnN0IHByb3BzVXJsID0gYGh0dHBzOi8vcHViY2hlbS5uY2JpLm5sbS5uaWguZ292L3Jlc3QvcHVnL2NvbXBvdW5kL2NpZC8ke2NpZH0vcHJvcGVydHkvTW9sZWN1bGFyRm9ybXVsYSxJVVBBQ05hbWUsTW9sZWN1bGFyV2VpZ2h0L0pTT05gO1xyXG4gICAgY29uc3QgcHJvcHNSZXNwb25zZSA9IGF3YWl0IGZldGNoKHByb3BzVXJsKTtcclxuICAgIFxyXG4gICAgaWYgKCFwcm9wc1Jlc3BvbnNlLm9rKSByZXR1cm4gbnVsbDtcclxuICAgIFxyXG4gICAgY29uc3QgcHJvcHNEYXRhID0gYXdhaXQgcHJvcHNSZXNwb25zZS5qc29uKCk7XHJcbiAgICBjb25zdCBwcm9wcyA9IHByb3BzRGF0YS5Qcm9wZXJ0eVRhYmxlPy5Qcm9wZXJ0aWVzPy5bMF07XHJcbiAgICBcclxuICAgIGlmICghcHJvcHMpIHJldHVybiBudWxsO1xyXG5cclxuICAgIGNvbnN0IG5hbWUgPSBwcm9wcy5JVVBBQ05hbWUgfHwgbmFtZVF1ZXJ5O1xyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBlbGVtZW50czogW10sXHJcbiAgICAgIGZvcm11bGE6IHByb3BzLk1vbGVjdWxhckZvcm11bGEgfHwgJ1Vua25vd24nLFxyXG4gICAgICBuYW1lOiBuYW1lLmxlbmd0aCA+IDUwID8gcHJvcHMuTW9sZWN1bGFyRm9ybXVsYSA6IG5hbWUsXHJcbiAgICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICBzdGF0ZTogJ1Vua25vd24nLFxyXG4gICAgICAgIG1lbHRpbmdfcG9pbnQ6ICdVbmtub3duJyxcclxuICAgICAgICBib2lsaW5nX3BvaW50OiAnVW5rbm93bicsXHJcbiAgICAgICAgZGVuc2l0eTogJ1Vua25vd24nXHJcbiAgICAgIH0sXHJcbiAgICAgIHVzZXM6IFsnQ2hlbWljYWwgY29tcG91bmQnLCAnUmVzZWFyY2gnLCAnSW5kdXN0cmlhbCBhcHBsaWNhdGlvbnMnXSxcclxuICAgICAgbGlua3M6IHtcclxuICAgICAgICB3aWtpcGVkaWE6IGBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS8ke2VuY29kZVVSSUNvbXBvbmVudChuYW1lKX1gLFxyXG4gICAgICAgIHB1YmNoZW06IGBodHRwczovL3B1YmNoZW0ubmNiaS5ubG0ubmloLmdvdi9jb21wb3VuZC8ke2NpZH1gXHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuZXJhdGVQb3NzaWJsZUZvcm11bGFzKGVsZW1lbnRzOiB7IHN5bWJvbDogc3RyaW5nOyBuYW1lOiBzdHJpbmcgfVtdKTogc3RyaW5nW10ge1xyXG4gIGNvbnN0IGZvcm11bGFzOiBzdHJpbmdbXSA9IFtdO1xyXG4gIGNvbnN0IHN5bWJvbHMgPSBlbGVtZW50cy5tYXAoZWwgPT4gZWwuc3ltYm9sKTtcclxuICBcclxuICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAyKSB7XHJcbiAgICBjb25zdCBbczEsIHMyXSA9IHN5bWJvbHM7XHJcbiAgICBmb3JtdWxhcy5wdXNoKFxyXG4gICAgICBgJHtzMX0ke3MyfWAsIGAke3MyfSR7czF9YCxcclxuICAgICAgYCR7czF9MiR7czJ9YCwgYCR7czJ9MiR7czF9YCxcclxuICAgICAgYCR7czF9JHtzMn0yYCwgYCR7czJ9JHtzMX0yYCxcclxuICAgICAgYCR7czF9MiR7czJ9M2AsIGAke3MyfTIke3MxfTNgLFxyXG4gICAgICBgJHtzMX0zJHtzMn0yYCwgYCR7czJ9MyR7czF9MmAsXHJcbiAgICAgIGAke3MxfTMke3MyfWAsIGAke3MyfTMke3MxfWAsXHJcbiAgICAgIGAke3MxfSR7czJ9M2AsIGAke3MyfSR7czF9M2AsXHJcbiAgICAgIGAke3MxfTQke3MyfWAsIGAke3MyfTQke3MxfWBcclxuICAgICk7XHJcbiAgfSBlbHNlIGlmIChlbGVtZW50cy5sZW5ndGggPT09IDMpIHtcclxuICAgIGNvbnN0IFtzMSwgczIsIHMzXSA9IHN5bWJvbHM7XHJcbiAgICBmb3JtdWxhcy5wdXNoKFxyXG4gICAgICBgJHtzMX0ke3MyfSR7czN9YCwgYCR7czF9JHtzM30ke3MyfWAsIGAke3MyfSR7czF9JHtzM31gLFxyXG4gICAgICBgJHtzMn0ke3MzfSR7czF9YCwgYCR7czN9JHtzMX0ke3MyfWAsIGAke3MzfSR7czJ9JHtzMX1gLFxyXG4gICAgICBgJHtzMX0yJHtzMn0ke3MzfWAsIGAke3MxfSR7czJ9MiR7czN9YCwgYCR7czF9JHtzMn0ke3MzfTJgLFxyXG4gICAgICBgJHtzMX0ke3MyfSR7czN9M2AsIGAke3MxfSR7czJ9MyR7czN9YCwgYCR7czF9MyR7czJ9JHtzM31gXHJcbiAgICApO1xyXG4gIH0gZWxzZSBpZiAoZWxlbWVudHMubGVuZ3RoID49IDQpIHtcclxuICAgIC8vIEZvciA0KyBlbGVtZW50cywgdHJ5IGJhc2ljIGNvbWJpbmF0aW9uc1xyXG4gICAgZm9ybXVsYXMucHVzaChzeW1ib2xzLmpvaW4oJycpKTtcclxuICAgIGZvcm11bGFzLnB1c2goc3ltYm9scy5yZXZlcnNlKCkuam9pbignJykpO1xyXG4gIH1cclxuICBcclxuICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KGZvcm11bGFzKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFBlcm11dGF0aW9uczxUPihhcnI6IFRbXSk6IFRbXVtdIHtcclxuICBpZiAoYXJyLmxlbmd0aCA8PSAxKSByZXR1cm4gW2Fycl07XHJcbiAgY29uc3QgcmVzdWx0OiBUW11bXSA9IFtdO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCByZXN0ID0gWy4uLmFyci5zbGljZSgwLCBpKSwgLi4uYXJyLnNsaWNlKGkgKyAxKV07XHJcbiAgICBjb25zdCBwZXJtcyA9IGdldFBlcm11dGF0aW9ucyhyZXN0KTtcclxuICAgIGZvciAoY29uc3QgcGVybSBvZiBwZXJtcykge1xyXG4gICAgICByZXN1bHQucHVzaChbYXJyW2ldLCAuLi5wZXJtXSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRFbGVtZW50V2lraXBlZGlhVXJsKGVsZW1lbnROYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gIHJldHVybiBgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvJHtlbmNvZGVVUklDb21wb25lbnQoZWxlbWVudE5hbWUpfWA7XHJcbn0iXSwibmFtZXMiOlsiY29tcG91bmRDYWNoZSIsIk1hcCIsImNvbXBvdW5kc0RhdGFiYXNlIiwibG9va3VwQ29tcG91bmQiLCJlbGVtZW50cyIsImVsZW1lbnROYW1lcyIsIm1hcCIsImVsIiwibmFtZSIsInNvcnRlZE5hbWVzIiwic29ydCIsImxvb2t1cEtleXMiLCJTZXQiLCJhZGQiLCJqb2luIiwicmV2ZXJzZSIsImxlbmd0aCIsInBlcm11dGF0aW9ucyIsImdldFBlcm11dGF0aW9ucyIsImZvckVhY2giLCJwZXJtIiwibG9va3VwS2V5c0FycmF5IiwiQXJyYXkiLCJmcm9tIiwia2V5IiwiaGFzIiwiZ2V0IiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwiRXJyb3IiLCJzdGF0dXMiLCJqc29uIiwiZXJyb3IiLCJjb25zb2xlIiwibG9jYWxDb21wb3VuZCIsInNldCIsInB1YmNoZW1Db21wb3VuZCIsInF1ZXJ5UHViQ2hlbUJ5RWxlbWVudHMiLCJmb3JtdWxhcyIsImdlbmVyYXRlUG9zc2libGVGb3JtdWxhcyIsImZvcm11bGEiLCJjb21wb3VuZCIsInF1ZXJ5UHViQ2hlbUJ5Rm9ybXVsYSIsIm5hbWVRdWVyeSIsInRvTG93ZXJDYXNlIiwibmFtZUNvbXBvdW5kIiwicXVlcnlQdWJDaGVtQnlOYW1lIiwicHJvcHNEYXRhIiwic2VhcmNoVXJsIiwiZGF0YSIsImNvbXBvdW5kcyIsIlBDX0NvbXBvdW5kcyIsImNpZCIsImlkIiwicHJvcHNVcmwiLCJwcm9wc1Jlc3BvbnNlIiwicHJvcHMiLCJQcm9wZXJ0eVRhYmxlIiwiUHJvcGVydGllcyIsIklVUEFDTmFtZSIsIk1vbGVjdWxhckZvcm11bGEiLCJwcm9wZXJ0aWVzIiwic3RhdGUiLCJtZWx0aW5nX3BvaW50IiwiYm9pbGluZ19wb2ludCIsImRlbnNpdHkiLCJ1c2VzIiwibGlua3MiLCJ3aWtpcGVkaWEiLCJlbmNvZGVVUklDb21wb25lbnQiLCJwdWJjaGVtIiwic3ltYm9scyIsInN5bWJvbCIsInMxIiwiczIiLCJwdXNoIiwiczMiLCJhcnIiLCJyZXN1bHQiLCJpIiwicmVzdCIsInNsaWNlIiwicGVybXMiLCJnZXRFbGVtZW50V2lraXBlZGlhVXJsIiwiZWxlbWVudE5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/compoundLookup.ts\n"));

/***/ })

}]);